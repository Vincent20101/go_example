package main

import (
	"log"
	"runtime"
	"runtime/debug"
)

func init() {
	log.SetFlags(log.LstdFlags)
}

func main() {
	//Go语言中的操作系统线程也叫工作线程，也就是GMP中M。所以这里操作系统线程数，也就是GMP中M的数量。
	//设置 Go 程序可以使用的最大操作系统线程数,超过设置，程序会崩溃。默认值为10000。
	//线程过多时会耗尽系统资源或者触发系统的限制导致程序异常，内核在调度大量线程时也要消耗额外的资源，限制 M 的数量主要是防止程序不合理的使用。
	//注意：
	//1. 这个设置限制的是操作系统线程数，而不是Goroutine的数量；
	//2.这个设置的上限取决于操作系统内核参数的限制。Linux 上有3个内核参数来限制内核参数的上限：
	///proc/sys/kernel/threads-max：表示系统支持的最大线程数；
	///proc/sys/kernel/pid_max：表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败；
	///proc/sys/vm/max_map_count：表示限制一个进程可以拥有的 VMA(虚拟内存区域)的数量；
	//返回值为之前的设置值
	log.Println("SetMaxThreads:", debug.SetMaxThreads(10000))

	//设置逻辑处理器P的个数,跟环境变量`GOMAXPROCS` 等价
	//默认值：对于官方标准编译器，在Go 1.5之前，默认初始逻辑处理器的数量为1；Go 1.5之后，默认初始逻辑处理器的数量和逻辑CPU的数量一致；
	//配置建议：在i/o密集型业务中设置P的个数大于CPU核数是有好处的，涉及到 I/O操作频繁的程序，单纯的计算能力可能并不是瓶颈，而是 I/O 操作的延迟。
	//返回值为之前的设置值
	log.Println("GOMAXPROCS:", runtime.GOMAXPROCS(2))

	//设置单个 goroutine 堆栈可以使用的最大内存量
	//默认值：64位系统上为1 GB(按照1KB=1000B字节算)，在32位系统上为250 MB
	//返回值为之前的设置值
	log.Println("SetMaxStack:", debug.SetMaxStack(1024*1024*1024))

	//Go1.19增加的软内存限制，跟GOMEMLIMIT环境变量等价，用于设置Go程序的内存限制。
	//`GOMEMLIMIT` 是一个以字节为单位的数值，可以带有可选的单位后缀，如 B、KiB、MiB、GiB 和 TiB，用于表示不同的容量大小
	//该限制通常用于确保程序不会占用过多的系统内存，特别是在内存有限的环境中。
	// 如果系统内存不足，Go 运行时将尝试采取措施来遵守这个限制，包括调整垃圾回收的频率和更积极地释放内存。
	//参数以字节为单位，用于指定内存限制的大小。这个限制包括所有由 Go 运行时映射、管理的内存，但不包括 Go 二进制文件的内存以及由 Go 之外的代码（如 C 代码）分配的内存。
	//也不包括由操作系统内核管理的进程内存。
	//注意：
	//如果设置了一个较小的限制，可能会导致垃圾回收几乎连续运行。但应用程序可能仍然可以继续运行，只是垃圾回收会更频繁。
	//为了有效地禁用这种内存限制行为，可以将限制设置为非常高的值。初始限制的默认值是 `math.MaxInt64`，但也可以设置比底层系统可用内存大得多的值。
	//函数返回值为先前设置的内存限制，如果传入负数，它将不会修改限制，而是返回当前设置的内存限制。
	//即使设置了 `GOGC=off` 也会生效该限制也会生效

	log.Println("SetMemoryLimit:", debug.SetMemoryLimit(-1))

}
