package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"regexp"
	"strings"
)

var buf bytes.Buffer

func main() {
	fileName := "H:/project/go_example/ast/tools/code/code.go"
	f, err := parser.ParseFile(token.NewFileSet(), fileName, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	fmt.Fprintf(&buf, "// Code generated by \"codegen %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintf(&buf, "\n")
	fmt.Fprintf(&buf, "package %s", "code")
	fmt.Fprintf(&buf, "\n")

	fmt.Fprintf(&buf, "func init() {\n")
	genDecl(f.Decls[0].(*ast.GenDecl))
	fmt.Fprintf(&buf, "}\n")
	src := []byte(buf.String())
	_ = os.WriteFile("H:/project/go_example/ast/tools/code/code_generated.go", src, 0600)
}

func genDecl(decl *ast.GenDecl) {
	for _, spec := range decl.Specs {
		vspec, _ := spec.(*ast.ValueSpec) // Guaranteed to succeed as this is CONST.
		for _, name := range vspec.Names {
			var comment string
			if vspec.Doc != nil && vspec.Doc.Text() != "" {
				comment = vspec.Doc.Text()
			} else if c := vspec.Comment; c != nil && len(c.List) == 1 {
				comment = c.Text()
			}
			//fmt.Println(name.Name, comment)
			h, s := ParseComment(name.Name, comment)
			fmt.Fprintf(&buf, "\tregister(%s, %s, \"%s\")\n", name.Name, h, s)
			fmt.Println(name.Name, h, s)

		}
	}

}

func ParseComment(varName, comment string) (string, string) {
	reg := regexp.MustCompile(`\w\s*-\s*(\d{3})\s*:\s*([A-Z].*)\s*\.\n*`)
	//fmt.Println(comment)
	if !reg.MatchString(comment) {
		return "500", "Internal server error"
	}

	groups := reg.FindStringSubmatch(comment)
	if len(groups) != 3 {
		return "500", "Internal server error"
	}

	return groups[1], groups[2]
}
