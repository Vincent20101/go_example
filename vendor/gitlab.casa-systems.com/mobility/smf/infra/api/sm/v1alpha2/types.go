package v1alpha2

// Profile of radius server
//
//	Purpose:
//	  This is default radius configuration to be used by SMF when interacting with external radius
//
//	Data model:
//	  Refer to the description for each attribute below
//
//	Usage:
//	  Used as value of radius server
type RadiusProfile struct {
	// Radius server fqdn \n
	// Mandatory
	Fqdn string `mapstructure:"fqdn" json:"fqdn"`
	// Radius server port \n
	// Authentication server port is 1812 \n
	// Accounting server port is 1813 \n
	// Mandatory
	Port uint `mapstructure:"port" json:"port"`
	// This field holds a text string that serves as a password between Radius server and Radius client \n
	// Mandatory
	Secret string `mapstructure:"secret" json:"secret"`
	// This field holds Radius request retransmission counts \n
	// Works in conjunction TimeoutSec \n
	// Mandatory
	RetryCount uint8 `mapstructure:"retryCount" json:"retryCount"`
	// This field holds Radius request timeout value \n
	// Unit is second \n
	// Mandatory
	TimeoutSec uint8 `mapstructure:"timeoutSec" json:"timeoutSec"`
	// SourceAddr string
}

// Specify Type of change of authorization allowed
type RadiusCoaDisconnectAction int

const (
	RADIUS_DISCONNECT RadiusCoaDisconnectAction = iota
	RADIUS_COA
	RADIUS_COA_DISCONNECT
)

const (
	SBI_MESSAGE_PRIORITY_INITIAL_HTTP_REQUEST    = 24
	SBI_MESSAGE_PRIORITY_SUBSEQUENT_HTTP_REQUEST = 23
	SBI_MESSAGE_PRIORITY_HTTP_RESPONSE           = 22
)

const (
	HTTPReqTimeoutAction_TIMED_OUT_REQUEST = "TIMED_OUT_REQUEST"
	HTTPReqTimeoutAction_Drop              = "DROP"
)

// Per DNN configuration for RADIUS change of authorization and disconnects
//
//	Purpose:
//	  Radius change of authorization or disconnect requests
//
//	Data model:
//	  Refer to the description for each attribute below
//
//	Usage:
//	  Used as value of radius
type RadiusCoaDisconnectProfile struct {
	// Remote client address we'll accept requests from \n
	// Mandatory
	ClientIpAddr string `mapstructure:"clientIpAddr" json:"clientIpAddr"`
	// Shared RADIUS secret for this DNN \n
	// Mandatory
	Secret string `mapstructure:"secret" json:"secret"`
	// Actions allowed for this DNN \n
	// - RADIUS_DISCONNECT \n
	// - RADIUS_COA \n
	// - RADIUS_COA_DISCONNECT \n
	// Mandatory
	Action RadiusCoaDisconnectAction `mapstructure:"action" json:"action"`
}

// External radius server configuration
//
//	Purpose:
//	  This is default radius configuration to be used by SMF when interacting with external radius
//
//	Data model:
//	  Refer to the description for each attribute below
//
//	Usage:
//	  Used as value of radius
type ExternalAaaProfile struct {
	// Authentication RADIUS server profile \n
	// Mandatory
	RadiusProfile RadiusProfile `mapstructure:"radiusProfile" json:"radiusProfile"`
	// RADIUS change of Authorization and Disconnects profile \n
	// Mandatory
	RadiusCoaDisconnectProfile RadiusCoaDisconnectProfile `mapstructure:"radiusCoaDisconnectProfile" json:"radiusCoaDisconnectProfile"`
	// RADIUS accounting profile \n
	// Mandatory
	RadiusAcctProfile []RadiusProfile `mapstructure:"radiusAcctProfile" json:"radiusAcctProfile"`
	// TODO:
	// Authentication/Authorization/Accounting configurable parameters
}

type ServiceAgent struct {
	Port    uint16 `mapstructure:"port" json:"port,omitempty"`
	UdmUecm bool   `mapstructure:"udmUecm" json:"udmUecm,omitempty"`
	UdmSdm  bool   `mapstructure:"udmSdm" json:"udmSdm,omitempty"`
	Pcf     bool   `mapstructure:"pcf" json:"pcf,omitempty"`
}

type Oauth2Algorithm string

const (
	HS256 Oauth2Algorithm = "HS256"
	HS384 Oauth2Algorithm = "HS384"
	HS512 Oauth2Algorithm = "HS512"
	RS256 Oauth2Algorithm = "RS256"
	RS384 Oauth2Algorithm = "RS384"
	RS512 Oauth2Algorithm = "RS512"
)

// Oauth2 Configuration
//
//	Purpose:
//	  Add Oauth2Cfg in configuration for smf as producer.
//
//	Data model:
//	  Refer to the description for attribute below.
//
//	Usage:
//	  The SMF and NRF should use the same Algorithm and SharedKey.
type Oauth2Cfg struct {
	// The SMF and NRF should use the same algorithm.\n
	// Default value "".\n
	// Mandatory.
	Algorithm Oauth2Algorithm `mapstructure:"algorithm" json:"algorithm"`
	// It is the path of the Oauth2 SharedKey file, and the resource server(SMF) will read the SharedKey from the file.
	// The resource server uses the SharedKey to parse the access token from the client
	// The SharedKey can be Public Key(Symmetric encryption) or Shared Secret(Asymmetric encryption)
	// Shared key is generated by NRF(NRF is a Oauth2 Authentication Server) and issued to NF resource server(SMF).
	// The supported key file formats are: .pem; .cert; .cer; .crt, etc.
	// eg.: Oauth2SharedKeyFilePath = "/etc/secrets/oauth2/oauth2SharedKey.pem"
	// Default value "".\n
	// Mandatory
	SharedKeyFilePath string `mapstructure:"sharedKeyFilePath" json:"sharedKeyFilePath"`

	// The SMF and NRF should use the same SharedKey.\n
	// Default value "".\n
	// NOTE: The SmfOauth2Cfg is only used up to version 6.3.0, will be deprecated after version 6.3.0 !!!
	// deprecated
	SharedKey string `mapstructure:"sharedKey" json:"sharedKey,omitempty"`

	// It is the storage level of requesting oauth2 token.
	// Value option: "NfInstance" (request oauth2 token for each Nf instance), "NfType" (request oauth2 token for each Nf type)
	// Default value: "" (same as "NfType", request oauth2 token for each Nf type)
	Oauth2TokenLevel string `mapstructure:"oauth2TokenLevel" json:"oauth2TokenLevel,omitempty"`
}

// SMF NAS level congestion control configuration
//
//	Purpose:
//	  Used to control NAS-level congestion control
//
//	Data model:
//	  Refer to the description for each attribute below
//
//	Usage:
//	  Overloadcontrol CRD defines the overload threshold and action for AMF and SMF. Triggers are usage percentage. Tolerance indicates how much lower than trigger for the overload state to be changed from true (enabled) to false.
type NasOverload struct {
	// Indicate if NAS overload is active
	// - "true" means enable
	// - "false" means not enable
	// Default value "false"
	// Optional
	Enabled bool `mapstructure:"enabled" json:"enabled,omitempty"`
	// Backoff period before NAS overload action starts, The value of "backoffTimerSeconds" must be greater than 0 second if "enabled" is true
	// Time unit: second
	// Optional
	BackoffTimerSeconds uint `mapstructure:"backoffTimerSeconds" json:"backoffTimerSeconds,omitempty"`
}

type OperatorOp uint32

const (
	OperatorOp_VzW_Phase_1 OperatorOp = 0x1
	OperatorOp_VzW_Phase_2 OperatorOp = 0x2
	OperatorOp_VzW_Phase_3 OperatorOp = 0x4
	OperatorOp_YTL_4G      OperatorOp = 0x8
	OperatorOp_YTL_NSA     OperatorOp = 0x10

	OperatorOp_VzW OperatorOp = 0x7
)

type FeatureOptions struct {
	// Feature flag to enable race condition handling between pcf and smf as defined in Ts29513
	// Optional
	PcfRaceConditionHandling bool `mapstructure:"pcfRaceConditionHandling" json:"pcfRaceConditionHandling,omitempty"`
	// Feature flag to enable base mandatory 4G features
	// Mandatory for OperatorOp: YTL_4G
	Var4GBase bool `mapstructure:"var4GBase" json:"var4GBase,omitempty"`
	// Feature flag to enable ignoring same pcc rule precedence error
	// Mandatory for OperatorOp: YTL_4G
	PccSamePrecedenceIgnore bool `mapstructure:"pccSamePrecedenceIgnore" json:"pccSamePrecedenceIgnore,omitempty"`
	// Feature flag to enable GTP cause 8(REACTIVATION_REQUESTED) for CLI batch release session
	// Mandatory for OperatorOp: YTL_4G
	CLIBatchRelGtpCause8 bool `mapstructure:"cLIBatchRelGtpCause8" json:"cLIBatchRelGtpCause8,omitempty"`
	// Feature flag to enable suppression update bearer request for default bearer when only bearer TFT updated
	// Mandatory for OperatorOp: YTL_4G
	DefaultBearerUpdateSuppression bool `mapstructure:"defaultBearerUpdateSuppression" json:"defaultBearerUpdateSuppression,omitempty"`
	// Feature flag to enable init quota trigger by 1 volume quota. issue: GCS-6688
	// Mandatory for OperatorOp: YTL_4G
	InitQuotaTrigger bool `mapstructure:"initQuotaTrigger" json:"initQuotaTrigger,omitempty"`
	// Feature flag to enable check pcscf ip health
	// Optional
	PcscfHealthCheckWithPing bool `mapstructure:"pcscfHealthCheckWithPing" json:"pcscfHealthCheckWithPing,omitempty"`
	// Feature flag to enable handle gy result code, drop and retry:3002 or 3004, drop:4010, terminate:5003
	// Mandatory for OperatorOp: YTL_4G
	GyResultCodeHandle bool `mapstructure:"gyResultCodeHandle" json:"gyResultCodeHandle,omitempty"`
	// Feature flag to enable not send Update Bearer Request to sgwc if there is no qos or ambr changed during modify bearer command procedure
	// Mandatory for OperatorOp: VzW_Phase_1
	SuppressUBRifNoQoSChange bool `mapstructure:"suppressUBRifNoQoSChange" json:"suppressUBRifNoQoSChange,omitempty"`
	// Feature flag to enable support configurable local policy on the SMF, to specify the desired QOS treatment in the event that the PCF is unreachable
	// Default value "false"
	// Optional
	PcfAssumePositive bool `mapstructure:"pcfAssumePositive" json:"pcfAssumePositive,omitempty"`
	// Feature flag to enable charging in emergency call flow
	// Default value "false"
	// Optional
	ECallEnableCharging bool `mapstructure:"eCallEnableCharging" json:"eCallEnableCharging,omitempty"`
	// Feature flag to enable use last valid cache when NRF returns error 503 , no response or timeout
	// Mandatory for OperatorOp: VzW_Phase_1
	NfUseLastValidCache bool `mapstructure:"nfUseLastValidCache" json:"nfUseLastValidCache,omitempty"`
	// Feature flag to enable SMF to manage IP Address Pools
	// Default value "false"
	// Optional
	IpPoolMgmtBySmf bool `mapstructure:"ipPoolMgmtBySmf" json:"ipPoolMgmtBySmf,omitempty"`
	// Feature flag to enable SMF to include sbi target api root
	// Default value "false"
	// Optional
	IncludeSbiTargetApiRoot bool `mapstructure:"includeSbiTargetApiRoot" json:"includeSbiTargetApiRoot,omitempty"`
	// VZW Feature flag ---------------------------------------------
	// Whether SMF supports NFSET
	// Optional
	NfSet bool `mapstructure:"nfSet" json:"nfSet,omitempty"`
	// whether to use RequesterNfInstanceFqdn to Select NF from NRF
	// Optional
	SelectNfWithRequesterFqdn bool `mapstructure:"selectNfWithRequesterFqdn" json:"selectNfWithRequesterFqdn,omitempty"`
	// whether to use SmfLocality to Select NF  from NRF
	// Optional
	SelectNfWithSmfLocality bool `mapstructure:"selectNfWithSmfLocality" json:"selectNfWithSmfLocality,omitempty"`
	// whether to use PreferredLocality to Select NF  from NRF
	// Optional
	SelectNfWithPreferredLocality bool `mapstructure:"selectNfWithPreferredLocality" json:"selectNfWithPreferredLocality,omitempty"`
	// Select NF whether is static first
	// Optional
	SelectNFStaticPreferred bool `mapstructure:"selectNFStaticPreferred" json:"selectNFStaticPreferred,omitempty"`
	// Whether to set correlation in 3gpp-Sbi-Correlation-Info sba header
	// Optional
	AddSbaHeaderCorrelation bool `mapstructure:"addSbaHeaderCorrelation" json:"addSbaHeaderCorrelation,omitempty"`
	// Whether to set priority in 3gpp-Sbi-Message-Priority sba header
	// Optional
	AddSbaHeaderPriority bool `mapstructure:"addSbaHeaderPriority" json:"addSbaHeaderPriority,omitempty"`
	// Whether to add timestamp by 3gpp-Sbi-Origination-Timestamp sba header
	// Optional
	AddSbaHeaderOriginTimestamp bool `mapstructure:"addSbaHeaderOriginTimestamp" json:"addSbaHeaderOriginTimestamp,omitempty"`
	// Whether to set UE PDN info to upf
	// Optional
	IncludeUePdnInfoToUpf bool `mapstructure:"includeUePdnInfoToUpf" json:"includeUePdnInfoToUpf,omitempty"`
	// Whether to use the virtual APN which is got from UDM
	// Optional
	UseUdmVirtualApn bool `mapstructure:"useUdmVirtualApn" json:"useUdmVirtualApn,omitempty"`
	// Whether to set pcf alway report ue location
	// Optional
	AlwaysReportUeLocToPcf bool `mapstructure:"alwaysReportUeLocToPcf" json:"alwaysReportUeLocToPcf,omitempty"`
	// Whether to set exclude accnetchid to pcf
	// Optional
	ExcludeAccNetChIdsToPcf bool `mapstructure:"excludeAccNetChIdsToPcf" json:"excludeAccNetChIdsToPcf,omitempty"`
	// whether enable delay quota for dynamic rule online charging rg
	// Optional
	DelayDynamicRuleQuotaRequest bool `mapstructure:"delayDynamicRuleQuotaRequest" json:"delayDynamicRuleQuotaRequest,omitempty"`
	// whether enable delay quota for static rule online charging rg
	// Optional
	DelayStaticRuleQuotaRequest bool `mapstructure:"delayStaticRuleQuotaRequest" json:"delayStaticRuleQuotaRequest,omitempty"`
	// whether enable release charging session when pdu session in idle state
	// Optional
	RelChargingForIdleSess bool `mapstructure:"relChargingForIdleSess" json:"relChargingForIdleSess,omitempty"`
	// whether enable report volume threshold by service IDs
	// Optional
	// Deprecated due to typo
	ReportVolumThresholdByServiceIds bool `mapstructure:"reportVolumThresholdByServiceIds" json:"reportVolumThresholdByServiceIds,omitempty"`
	// whether enable report volume threshold by service IDs
	// Optional
	ReportVolumeThresholdByServiceIds bool `mapstructure:"reportVolumeThresholdByServiceIds" json:"reportVolumeThresholdByServiceIds,omitempty"`
	// whether charging UUC's LSN increase per rating group
	// Optional
	// Deprecated due to default mode
	IsLSNPerRg bool `mapstructure:"isLSNPerRg" json:"isLSNPerRg,omitempty"`
	// whether charging UUC's LSN increase per session, if it's true, ignore isLSNPerRg
	// Optional
	EnableLSNPerSess bool `mapstructure:"enableLSNPerSess" json:"enableLSNPerSess,omitempty"`
	// whether enable chf assume positive
	// Optional
	ChfAssumePositive bool `mapstructure:"chfAssumePositive" json:"chfAssumePositive,omitempty"`
	// whether report all pcf Pras to chf
	// Optional
	ReportAllPcfPrasToChf bool `mapstructure:"reportAllPcfPrasToChf" json:"reportAllPcfPrasToChf,omitempty"`
	// Feature flag to enable SMF to set rg offline false if both rg online and offline are true
	// Optional
	TreatBothOnlineOfflineRgAsOnlineOnly bool `mapstructure:"treatBothOnlineOfflineRgAsOnlineOnly" json:"treatBothOnlineOfflineRgAsOnlineOnly,omitempty"`
	// Whether to get AMF hostport from the callback uri,if nrf is not available
	// Optional
	UseAmfFromCallbackUri bool `mapstructure:"useAmfFromCallbackUri" json:"UseAmfFromCallbackUri,omitempty"`
	// Feature flag to enable select api version by priority.
	// Default value "false"
	// Optional
	SelectApiVersionByPriority bool `mapstructure:"selectApiVersionByPriority" json:"selectApiVersionByPriority,omitempty"`
	// Feature flag to enable choose the api version by configuring the optimal version.
	// Default value "false"
	// Optional
	// Deprecated due to typo
	SelectApiVersionByPerference bool `mapstructure:"selectApiVersionByPerference" json:"selectApiVersionByPerference,omitempty"`
	// Feature flag to enable choose the api version by configuring the optimal version.
	// Default value "false"
	// Optional
	SelectApiVersionByPreference bool `mapstructure:"selectApiVersionByPreference" json:"selectApiVersionByPreference,omitempty"`
	// Whether to disable Indicate interneting with  EPS is subscribed to select slice
	// Optional
	DisableSelectSmDataByIwkEpsInd bool `mapstructure:"disableSelectSmDataByIwkEpsInd" json:"disableSelectSmDataByIwkEpsInd,omitempty"`
	//Whether to disable subscribe ue reach ability event
	// Optional
	DisableSubscribeUeReachability bool `mapstructure:"disableSubscribeUeReachability" json:"disableSubscribeUeReachability,omitempty"`
	//Whether to use timer to releases any S5-U TEID in the UPF
	//if the smf does not receive the Modify Bearer Request in 5GC to EPS handover or TAU to LTE procedure when the timer expires
	// Optional
	EnableTimerToRelS5uWhenHO54 bool `mapstructure:"enableTimerToRelS5uWhenHO54" json:"enableTimerToRelS5uWhenHO54,omitempty"`
	//whether to SMF shall start a backoff timer at paging failure and retry paging to AMF/UE after timer timeout
	// Optional
	EnablePagingRetryBackoff bool `mapstructure:"enablePagingRetryBackoff" json:"enablePagingRetryBackoff,omitempty"`
	// V1 error handling
	// Optional
	EnableErrorHandlingSet1 bool `mapstructure:"enableErrorHandlingSet1" json:"enableErrorHandlingSet1,omitempty"`
	// V2 error handling
	// Optional
	EnableErrorHandlingSet2 bool `mapstructure:"enableErrorHandlingSet2" json:"enableErrorHandlingSet2,omitempty"`
	// Whether to ignore errors in UDM registration and subscription
	// Optional
	IgnoreUDMRegisterAndSubscribeError bool `mapstructure:"ignoreUDMRegisterAndSubscribeError" json:"ignoreUDMRegisterAndSubscribeError,omitempty"`
	//Weather SMF should use OfflineTariffTimeChange in VzChargingOptions IE
	// Optional
	EnableOfflineTtc bool `mapstructure:"enableOfflineTtc" json:"enableOfflineTtc,omitempty"`
	//Weather SMF should use BCR Reporting Time in VzChargingOptions IE
	// Optional
	EnableBcrReportingTime bool `mapstructure:"enableBcrReportingTime" json:"enableBcrReportingTime,omitempty"`
	// Whether to mask UE ID
	// Default value "false"
	// Optional
	MaskUeId bool `mapstructure:"maskUeId" json:"maskUeId,omitempty"`
	// Whether to mask UE ID in trace
	// Default value "false"
	// Optional
	MaskUeIdInTrace bool `mapstructure:"maskUeIdInTrace" json:"maskUeIdInTrace,omitempty"`
	// Whether to enable server header handling
	// Default value "false"
	// Optional
	EnableServerHeaderHandling bool `mapstructure:"enableServerHeaderHandling" json:"enableServerHeaderHandling,omitempty"`
	// Feature flag to enable DPDRA feature on SMF
	// Default value "false"
	// Optional
	Dpdra bool `mapstructure:"dpdra" json:"dpdra,omitempty"`
	// Whether to enable judgment specific to a subscriber
	// Default value "false"
	// Optional
	SubscriberDisableNfCache bool `mapstructrue:"subscriberDisableNfCache" json:"subscriberDisableNfCache,omitempty"`
	// Whether to enable support terminate session when all mscc exhausted
	// Default value "false"
	// Optional
	RelSessOfAllMsccExhaust bool `mapstructrue:"relSessOfAllMsccExhaust" json:"relSessOfAllMsccExhaust,omitempty"`
	// Whether to enable IUPF-related operations
	// Default value "false"
	// Optional
	EnableIUPF bool `mapstructrue:"enableIUPF" json:"enableIUPF,omitempty"`
	// Whether to disable internal msg metrics
	// Default value "false"
	// Optional
	DisableInternalMsgMetrics bool `mapstructrue:"disableInternalMsgMetrics" json:"disableInternalMsgMetrics,omitempty"`
	// whether SMF (as consumer) needs to request token from NRF when producer profile doesn't have Oauth2Required attribute set
	// - true: SMF will need to request token when producer Oauth2Required attribute is absent
	// - false: SMF will not need to request token when producer Oauth2Required attribute is absent
	// Default: false
	// Optional
	EnforceOauthTokenRequest bool `mapstructrue:"enforceOauthTokenRequest" json:"enforceOauthTokenRequest,omitempty"`
	// Whether SMF use the pcscf fqdn from Udm.
	// - true: SMF will use pcscf fqdn from Udm, and use look-uped ip or cached ip, or cached re-used ip from dns, if can't get any ips then terminate the request.
	// - false: SMF will not use pcscf fqdn from Udm, it will use the local config or discover pcscf from nrf.
	// Default: false
	// Optional
	PcscfFqdnFromUdm bool `mapstructrue:"pcscfFqdnFromUdm" json:"pcscfFqdnFromUdm,omitempty"`
	// Whether to enable error response enhancement
	// - true: SMF will use enhance format for ProblemDetails/detail
	// - false: SMF will use simple format for ProblemDetails/detail
	// Default: false
	// Optional
	EnableSbiErrRspDetail bool `mapstructrue:"enableSbiErrRspDetail" json:"enableSbiErrRspDetail,omitempty"`

	// Whether SMF set EdrInfo to UPF
	// Default value "false"
	// Optional
	IncludeEdrInfoToUpf bool `mapstructrue:"includeEdrInfoToUpf" json:"includeEdrInfoToUpf,omitempty"`
	// if enable to send  ga cdr to CGF
	// Default value "false"
	// Optional
	EnableGaInterface bool `mapstructrue:"enableGaInterface" json:"enableGaInterface,omitempty"`
	// A flag to enable recovery when program panic
	// Default: false
	// Optional
	EnablePanicRecoverAll bool `mapstructure:"enablePanicRecoverAll" json:"enablePanicRecoverAll,omitempty"`
	// Whether to enable split cdr by volume
	// Default: false
	// Optional
	EnableSplitCdrByVolume bool `mapstructure:"enableSplitCdrByVolume" json:"enableSplitCdrByVolume,omitempty"`
	// Whether to enable amf status change notification
	// Default: false
	// Optional
	EnableAMFStatusChange bool `mapstructure:"enableAMFStatusChange" json:"enableAMFStatusChange"`
	// Whether to enable or disable ST-MRT request headers handle
	// Default: false
	// Optional
	EnableStAndMrt bool `mapstructure:"enableStAndMrt" json:"enableStAndMrt,omitempty"`
}

// Smfsm service configuration
//
//	Purpose:
//	  This is default service configuration to be used by Smfsm
//
//	Data model:
//	  Refer to the description for each attribute below
//
//	Usage:
//	  Used as value of SvcCfg
type SmfSvcCfg struct {
	// FeatureOptions contains feature flags that need feature control for user \n
	// Optional
	FeatureOptions FeatureOptions `mapstructure:"featureOptions" json:"featureOptions,omitempty"`
	// Profile of SMF NF \n
	// Mandatory.
	SmfProfile SmfNfProfile `mapstructure:"smfProfile" json:"smfProfile"`
	// SBA public IP(s) for coding notification URIs for subscription to other NF (i.e. NRF) \n
	// Mandatory.
	PublicIP string `mapstructure:"publicIp" json:"publicIp"`
	// SBA public FQDN for coding notification URIs for subscription to other NF (i.e. NRF) \n
	// Optional.
	PublicFqdn string `mapstructure:"publicFqdn" json:"publicFqdn"`
	// SmfPort default 80 \n
	// Optional
	SmfPort uint `mapstructure:"smfPort" json:"smfPort,omitempty"`
	// ExtSmfSvcPort default 80.\n
	// Externally visible service port.\n
	// Populated by controller based on port forwarding configuration for SmfPort.\n
	// Optional
	ExtSmfSvcPort uint `mapstructure:"extSmfSvcPort" json:"extSmfSvcPort,omitempty"`
	// SmMgmtPort default 50057 \n
	// Is used to manage the NF cache \n
	// Optional
	SmMgmtPort uint `mapstructure:"smMgmtPort" json:"smMgmtPort,omitempty"`
	// TrcMgmtPort default 50058 \n
	// Is used to manage trace config \n
	// Optional
	TrcMgmtPort uint `mapstructure:"trcMgmtPort" json:"trcMgmtPort,omitempty"`
	// Redis-db fqdn \n
	// Mandatory.
	DbFqdn string `mapstructure:"dbFqdn" json:"dbFqdn"`
	// Redis-db port, default 6379 \n
	// Optional
	DbPort uint `mapstructure:"dbPort" json:"dbPort,omitempty"`
	// Redis-db fqdn for ip-pool \n
	// Optional
	IpPoolDbFqdn string `mapstructure:"ipPoolDbFqdn" json:"ipPoolDbFqdn,omitempty"`
	// Redis-db port for ip-pool, default 6379 \n
	// Optional
	IpPoolDbPort uint `mapstructure:"ipPoolDbPort" json:"ipPoolDbPort,omitempty"`
	// A path used to get metrics from sm \n
	// Mandatory.
	MetricPath string `mapstructure:"metricPath" json:"metricPath"`
	// The port which prometheus get metrics from sm \n
	// Mandatory.
	MetricPort uint `mapstructure:"metricPort" json:"metricPort"`
	// Etcd-db fqdn \n
	// Mandatory.
	EtcdFqdn string `mapstructure:"etcdFqdn" json:"etcdFqdn,omitempty"`
	// Etcd-db port, default EtcdPort 2379 \n
	// Optional
	EtcdPort uint `mapstructure:"etcdPort" json:"etcdPort,omitempty"`
	// Pfcp-svc fqdn, used for grpc connection with pfcp-svc \n
	// Mandatory.
	PfcpSvcFqdn string `mapstructure:"pfcpSvcFqdn" json:"pfcpSvcFqdn"`
	// Pfcp-svc port, used for grpc connection with pfcp-svc \n
	// Mandatory.
	PfcpSvcPort uint `mapstructure:"pfcpSvcPort" json:"pfcpSvcPort"`
	// PfcpSvc PublicIP(s) for coding for node-id in pfcp message and gtpu fteid for UPF send request to SMF \n
	// Mandatory.
	PfcpSvcPublicIp string `mapstructure:"pfcpSvcPublicIp" json:"pfcpSvcPublicIp"`
	// Anpd-svc fqdn, used for internal grpc connection with eime-Anpd-svc \n
	// Mandatory.
	EimeSvcFqdn string `mapstructure:"eimeSvcFqdn" json:"eimeSvcFqdn"`
	// Anpd-svc port, used for internal grpc connection with eime-Anpd-svc \n
	// Mandatory.
	EimeSvcPort uint `mapstructure:"eimeSvcPort" json:"eimeSvcPort"`
	// Upfmgr-svc fqdn, used for grpc connection with upfmgr-svc \n
	// Mandatory.
	UpfSvcFqdn string `mapstructure:"upfSvcFqdn" json:"upfSvcFqdn"`
	// Upfmgr-svc port, used for grpc connection with upfmgr-svc \n
	// Mandatory.
	UpfSvcPort uint `mapstructure:"upfSvcPort" json:"upfSvcPort"`
	// Crs-svc fqdn, used for grpc connection with crs-svc \n
	// Mandatory.
	CtfSvcFqdn string `mapstructure:"ctfSvcFqdn" json:"ctfSvcFqdn"`
	// Crs-svc port, used for grpc connection with crs-svc \n
	// Optional
	CtfSvcPort uint `mapstructure:"ctfSvcPort" json:"ctfSvcPort,omitempty"`
	// Pgwc-svc fqdn, used for grpc connection with pgwc-svc \n
	// Optional
	PgwcSvcFqdn string `mapstructure:"pgwcSvcFqdn" json:"pgwcSvcFqdn,omitempty"`
	// Pgwc-svc port, used for grpc connection with pgwc-svc \n
	// Optional
	PgwcSvcPort uint `mapstructure:"pgwcSvcPort" json:"pgwcSvcPort,omitempty"`
	// deprecated, for backward-compatibility
	// NRF NF's fqdn, used for SBA-HTTP connection with NRF \n
	// Optional
	NrfSvcFqdn string `mapstructure:"nrfSvcFqdn" json:"nrfSvcFqdn,omitempty"`
	// deprecated, for backward-compatibility
	// NRF NF's port, used for SBA-HTTP connection with NRF \n
	// Optional
	NrfSvcPort uint `mapstructure:"nrfSvcPort" json:"nrfSvcPort,omitempty"`
	// NRF instance config, used for config NRF address/port etc
	// Optional
	Nrfs []NrfInstance `mapstructure:"nrfs" json:"nrfs,omitempty"`
	// Cms-svc fqdn, used for NCHF SBA-HTTP connection with Cms-svc, if it is empty, it means CMS integration is disabled. \n
	// Optional
	CmsSvcFqdn string `mapstructure:"cmsSvcFqdn" json:"cmsSvcFqdn,omitempty"`
	// Cms-svc port, used for NCHF SBA-HTTP connection with Cms-svc \n
	// Optional
	CmsSvcPort uint `mapstructure:"cmsSvcPort" json:"cmsSvcPort,omitempty"`
	// smf as client, Limgr fqdn, used for smf connect to the service of Lawful Interception, if it is empty, it means service of Lawful Interception is disabled. \n
	// Optional
	LimgrSvcFqdn string `mapstructure:"limgrSvcFqdn" json:"limgrSvcFqdn,omitempty"`
	// smf as client, Limgr port, used for smf connect to the service of Lawful Interception \n
	// Optional
	LimgrGrpcSvcPort uint `mapstructure:"limgrGrpcSvcPort" json:"limgrGrpcSvcPort,omitempty"`
	// smf as server, used for the service of Lawful Interception connect to smf \n
	// Optional
	LimgrGrpcCliPort uint `mapstructure:"limgrGrpcCliPort" json:"limgrGrpcCliPort,omitempty"`
	// key used to encrypt/decrypt msgs sent/reecived to/from limgr \n
	// This is is  required under the geo function, the values of active and standby instances need to be equal. \n
	// Populated by SMF operator \n
	// Default value is smfSetId. \n
	// Optional.
	LimgrEncryptionKey string `mapstructure:"limgrEncryptionKey" json:"limgrEncryptionKey,omitempty"`
	// Timer-svc fqdn, used for grpc connection with timer-svc \n
	// Optional
	TimerSvcFqdn string `mapstructure:"timerSvcFqdn" json:"timerSvcFqdn,omitempty"`
	// Timer-svc port, used for grpc connection with timer-svc \n
	// Default value 50051.\n
	// Optional
	TimerSvcPort uint `mapstructure:"timerSvcPort" json:"timerSvcPort,omitempty"`
	// Timer-svc callback fqdn, used for timer-svc grpc connection with smf \n
	// Optional
	TimerCallbackFqdn string `mapstructure:"timerCallbackFqdn" json:"timerCallbackFqdn,omitempty"`
	// Timer-client port, used for timer server connection with smf \n
	// Default value 50063.\n
	// Optional
	TimerCliPort uint `mapstructure:"timerCliPort" json:"timerCliPort,omitempty"`
	// S5 GTPC-svc fqdn, used for grpc connection with S5 GTPC-svc \n
	// Optional
	GtpcSvcFqdn string `mapstructure:"gtpcSvcFqdn" json:"gtpcSvcFqdn,omitempty"`
	//  S8 GTPC-svc fqdn, used for grpc connection with S8 GTPC-svc \n
	// Optional
	GtpcS8SvcFqdn string `mapstructure:"gtpcS8SvcFqdn" json:"gtpcS8SvcFqdn,omitempty"`
	// GTPC-svc port, used for grpc connection with GTPC-svc \n
	// Default value 50056.\n
	// Optional
	GtpcSvcPort uint `mapstructure:"gtpcSvcPort" json:"gtpcSvcPort,omitempty"`
	// GtpcSvc-S5 PublicIP(s) for coding for pgw-c Fteid in S8 gtpc message towards sgw-c \n
	// Mandatory.
	GtpcSvcPublicIp string `mapstructure:"gtpcSvcPublicIp" json:"gtpcSvcPublicIp"`
	// GtpcSvc-S8 PublicIP(s) for coding for pgw-c Fteid in S8 gtpc message towards sgw-c \n
	// Optional.
	GtpcS8SvcPublicIp string `mapstructure:"gtpcS8SvcPublicIp" json:"gtpcS8SvcPublicIp,omitempty"`
	// GtpcSvc PublicFqdn for coding for pgw-c Fteid in gtpc message towards sgw-c \n
	// Optional.
	GtpcSvcPublicFqdn string `mapstructure:"gtpcSvcPublicFqdn" json:"gtpcSvcPublicFqdn"`
	// smf as server, used for the service of Aaa-Client connect to smf \n
	// Default value 50059.\n
	// Optional
	AaaCliPort uint `mapstructure:"aaaCliPort" json:"aaaCliPort,omitempty"`
	// PCMS svc fqdn, used for HTTP connection with PCMS svc \n
	// Optional
	PcmsSvcFqdn string `mapstructure:"pcmsSvcFqdn" json:"pcmsSvcFqdn,omitempty"`
	// PCMS svc port, used for HTTP connection with PCMS svc \n
	// Default value 50051.\n
	// Optional
	PcmsSvcPort uint `mapstructure:"pcmsSvcPort" json:"pcmsSvcPort,omitempty"`
	// CdrMgrs related configuration
	// Optional
	// Deprecated due to just one cdr server's fqdn and port is needed.
	CdrMgrInstances []CdrMgrInstanceInfo `mapstructure:"cdrMgrInstances" json:"cdrMgrInstances,omitempty"`
	// CdrMgr Fqdn - SM needs this to send AP charging messages
	// Optional
	CdrMgrFqdn string `mapstructure:"cdrMgrFqdn" json:"cdrMgrFqdn,omitempty"`
	// CdrMgr Port - SM needs this to send AP charging messages
	// Optional
	CdrMgrPort uint16 `mapstructure:"cdrMgrPort" json:"cdrMgrPort,omitempty"`
	// Enable/disable Dnn Selection Mode feature.\n
	// -true: enable\n
	// -false disable.\n
	// Default value false.\n
	// Optional.
	EnableDnnSelMode bool `mapstructure:"enableDnnSelMode" json:"enableDnnSelMode,omitempty"`
	// Config for oauth2 authentication with NRF. \n
	// Optional
	SmfOauth2Cfg Oauth2Cfg `mapstructure:"smfOauth2Cfg" json:"smfOauth2Cfg,omitempty"`
	// What level of the logs will be printed.\n
	//  -"error"
	//  -"warn"
	//  -"info"
	//  -"debug"
	//  -"trace"
	// Default: "info"
	// Optional
	LogLevel string `mapstructure:"logLevel" json:"logLevel,omitempty"`
	// Used to display all levels of logs for a specific interface. \n
	//  -"ALL"
	//  -"DB"
	//  -"NSMF"
	//  -"NAMF"
	//  -"NPCF"
	//  -"NCHF"
	//  -"NNRF"
	//  -"NSSF"
	//  -"NUDM"
	//  -"GTPC"
	//  -"PFCP"
	//  -"NAS"
	//  -"NGAP"
	//  -"MGMT"
	//  -"FSM"
	//  -"PCSCF"
	//  -"RADIUS"
	//  -"DHCP"
	//  -"NNEF"
	//  -"PFDM"
	// Default: ""
	// Optional
	LogIfMask string `mapstructure:"logIfMask" json:"logIfMask,omitempty"`
	// The timeout value of each procedure timer. \n
	// Uint: Seconds
	// Default: 10
	// Optional
	ProcedureTimer uint `mapstructure:"procedureTimer" json:"procedureTimer,omitempty"`
	// A flag to enable recovery when program panicked \n
	//  -true
	//  -false
	// Default: true
	// Optional
	EnablePanicRecover bool `mapstructure:"enablePanicRecover" json:"enablePanicRecover,omitempty"`
	// Config smf action if the request timeout.
	// - "TIMED_OUT_REQUEST" (default):
	//    SMF shall reject a request that is known to have timed out with the
	//    HTTP status code "504 Gateway Timeout" and the protocol error
	//    "TIMED_OUT_REQUEST".
	// - "DROP":
	//    Drop the request.
	HttpReqTimeoutAction string `mapstructure:"httpReqTimeoutAction" json:"httpReqTimeoutAction,omitempty"`

	// HTTP/2 message priority value from 0 to 31, as defined in TS29500
	// clause 6.8.4.
	//
	// A message with 3gpp-Sbi-Message-Priority "0" has the highest priority.
	SbiMsgPriority *SbiMsgPriority `json:"sbiMsgPriority,omitempty"`

	// A flag to control what new-added features can be enabled. \n
	// Optional
	FeatureFlags uint64 `mapstructure:"featureFlags"    json:"featureFlags,omitempty"`
	// The sampling percentage of metric. Using for prometheus histogram. \n
	//  -100(100%): means that collect the total number,such as 1,2,3, ... in duration. \n
	//  -10(10%): means that collect 10% of the total number. it just collect datas as 10, 20, 30, ... in duration. \n
	//  -5(5%): means that collect 5% of the total number. it just collect datas as  20, 40,  60, ... in duration. \n
	//  -0: means disable
	// Uint: Percentage
	// Default: 0
	// Optional
	LatencySamplingPercentage uint `mapstructure:"latencySamplingPercentage"    json:"latencySamplingPercentage,omitempty"`
	// LatencyBuckets contains three latency buckets \n
	// Optional
	LatencyBuckets LatencyBuckets `mapstructure:"latencyBuckets"    json:"latencyBuckets,omitempty"`
	// PublicIp(s) for radius server to send CoA/Terminate message to SMF \n
	// Optional
	RadiusEndpointPublicIp string `mapstructure:"radiusEndpointPublicIp"    json:"radiusEndpointPublicIp,omitempty"`
	// PublicIP(s) for UPF to send gtpu pkt e.g. RS message to SMF(Deprecated, replace with PfcpSvcPublicIp) \n
	// Optional
	GtpuTunnelPublicIp string `mapstructure:"gtpuTunnelPublicIp" json:"gtpuTunnelPublicIp,omitempty"`
	// Enable/disable GTPU tunnel setup between SMF and UPF for SLAAC procedure within ipv6 PDN type PDU session setup.\n
	// UPF needs to handle RS/RA locally if SMF disables the tunnel setup
	// -true: enable\n
	// -false disable.\n
	// Default value false.\n
	// Optional.
	EnableSlaac bool `mapstructure:"enableSlaac" json:"enableSlaac,omitempty"`
	// ip address type preference in dual stack setup e.g. ipv4, ipv6, prefer ipv6 if both can work.\n
	//  -"ipv4"
	//  -"ipv6"
	//  -""
	// Default value ""
	// Optional
	DualStackPreference DualStackPreference `mapstructure:"dualStackPreference" json:"dualStackPreference,omitempty"`
	// This IE shall be present if Ethernet traffic reporting is used and
	// the SMF requests the UP function to also report inactive UE MAC addresses.
	// When present, it shall contain the duration of the Ethernet inactivity period \n
	// Uint: Seconds
	// Default: 30
	// Optional
	EthernetInactivityTimer uint32 `mapstructure:"ethernetInactivityTimer" json:"ethernetInactivityTimer,omitempty"`
	// SMF supported operator's requirement version/phase.
	// This is used to switch support among operator customized requirements from different operators
	// or among different versions/phases of requirements from same operator.
	// Operator customized requirement includes data model, api, call flows, etc.
	// Default value 0
	// Optional
	OperatorOption OperatorOp `mapstructure:"operatorOption" json:"operatorOption,omitempty"`
	// SMF Pod restart counter, the value changes when Pod restarts.
	// This is used in GTPC msg to indicate the peer NF of the recovery of the current NF.
	// Value in range 0~255.
	// Default value 0
	// Optional
	Recovery uint8 `mapstructure:"recovery" json:"recovery,omitempty"`
	// Indicates to enable smf to forward charging messages to DN-AAA through the N40-lite interface.
	// Default value: false
	// Deprecated: Use N40LiteCfg.EnableN40Lite instead
	// Optional
	EnableN40Lite bool `mapstructure:"enableN40Lite" json:"enableN40Lite,omitempty"`
	// This IE is used to classify the label values of the dedicated bearer duration metric. For example, when
	// configured as [30s 5m 20m 1h], the dedicated bearer duration metric will be classified into the following 5 label
	// values: "<30s", "30s~5m", "5m~20m", "20m~1h", ">=1h".
	// Default value is [30s 5m 20m 1h]
	// Optional
	BearerDurationMetricRangeThreshold []string `mapstructure:"bearerDurationMetricRangeThreshold" json:"bearerDurationMetricRangeThreshold,omitempty"`
	// This IE is used to configure the interval at which Create Bearer Request and Update Bearer Request are
	// re-initiated. When a Create Bearer Request or Update Bearer Request initiated by SMF is indicated to have been
	// temporarily rejected because of an ongoing handover/TAU/RAU procedure, SMF will initiate a guard timer
	// corresponding to this interval and re-initiate the above message after the guard timer has expired.
	// The unit is milliseconds, the range is 100 to 3000 and the default value is 300.
	// Optional
	ReAttemptCreateUpdateBearerInterval uint32 `mapstructure:"reAttemptCreateUpdateBearerInterval" json:"reAttemptCreateUpdateBearerInterval,omitempty"`
	// Configuration related to Namf interface.\n
	// Optional
	Namf *NamfCfg `mapstructure:"namf" json:"namf,omitempty"`
	// Configuration related to N1 interface.\n
	// Optional
	N1 *N1Cfg `mapstructure:"n1" json:"n1,omitempty"`
	// Configuration related to N2 interface.\n
	// Optional
	N2 *N2Cfg `mapstructure:"n2" json:"n2,omitempty"`
	// Configuration related to Npcf interface.\n
	// Optional
	Npcf *NpcfCfg `mapstructure:"npcf" json:"npcf,omitempty"`
	// Configuration related to Nchf interface.\n
	// Optional
	Nchf *NchfCfg `mapstructure:"nchf" json:"nchf,omitempty"`
	// Configuration related to Nnef interface.\n
	// Optional
	Nnef *NnefCfg `mapstructure:"nnef" json:"nnef,omitempty"`
	// Configuration related to Nnrf interface.\n
	// Optional
	Nnrf *NnrfCfg `mapstructure:"nnrf" json:"nnrf,omitempty"`
	// Configuration related to Nsmf interface.\n
	// Optional
	Nsmf *NsmfCfg `mapstructure:"nsmf" json:"nsmf,omitempty"`
	// Configuration related to Nudm interface.\n
	// Optional
	Nudm *NudmCfg `mapstructure:"nudm" json:"nudm,omitempty"`
	// Configuration related to Nudm interface.\n
	// Optional
	Gx *DiameterIntfCfg `mapstructure:"gx" json:"gx,omitempty"`
	// Configuration related to Nudm interface.\n
	// Optional
	Gy *DiameterIntfCfg `mapstructure:"gy" json:"gy,omitempty"`
	// Configuration related to Pcscf interface.\n
	// Optional
	Pcscf *PcscfCfg `mapstructure:"pcscf" json:"pcscf,omitempty"`
	// Configuration related to S5S8 interface.\n
	// Optional
	S5S8 *S5S8Cfg `mapstructure:"s5s8" json:"s5s8,omitempty"`
	// Configuration related to grpc interface to gtpc service.\n
	// Optional
	GtpcSvcGrpc *GtpcGrpcCfg `mapstructure:"gtpcSvcGrpc" json:"gtpcSvcGrpc,omitempty"`
	// Configuration related to grpc interface to pfcp service.\n
	// Optional
	PfcpSvcGrpc *PfcpGrpcCfg `mapstructure:"pfcpSvcGrpc" json:"pfcpSvcGrpc,omitempty"`
	// Configuration related to grpc interface to CdrMgr service.\n
	// Optional
	CdrMgrSvcGrpc *CdrMgrGrpcCfg `mapstructure:"cdrMgrSvcGrpc" json:"cdrMgrSvcGrpc,omitempty"`
	// Configuration related to grpc interface to aaa client service.\n
	// Optional
	AaaClientSvcGrpc *AaaClientGrpcCfg `mapstructure:"aaaClientSvcGrpc" json:"aaaClientSvcGrpc,omitempty"`
	// The IE indicates the list of available aaa-client services
	// Default value: nil
	// Optional
	AaaClientInfoList []AaaClientInfo `mapstructure:"aaaClientInfoList" json:"aaaClientInfoList,omitempty"`
	// Configure SCP server
	// Default value is nil
	// Optional
	Scps *ScpConfig `mapstructure:"scps" json:"scps,omitempty"`
	// Configure micro-service health check, each bit represents a state
	// Default value is 0
	// Optional
	HealthCheck uint64 `mapstructure:"healthCheck" json:"healthCheck,omitempty"`
	// RmSvcFqdn used for connection with RmSvc.
	// Optional
	RmSvcFqdn string `mapstructure:"rmSvcFqdn" json:"rmSvcFqdn,omitempty"`
	// RmSvcPort used for connection with RmSvc.
	// Default value is 80
	// Optional
	RmSvcPort uint `mapstructure:"rmSvcPort" json:"rmSvcPort,omitempty"`
	// IsStandby show whether the current state is standby
	// Default value is false
	// Optional
	IsStandby bool `mapstructure:"isStandby" json:"isStandby,omitempty"`
	// ObjectCfg is use config object relate info, set by operator
	// Default value is nil
	// Optional
	ObjectCfg *ObjectCfg `mapstructure:"objectCfg" json:"objectCfg,omitempty"`
	// DisableFailoverTriggers means that if configured and all health check cause values in it, health check will resp ok,failover will be ignored
	// now only support configure NRFS and SCPS
	// Optional
	DisableFailoverTriggers []string `mapstructure:"disableFailoverTriggers" json:"disableFailoverTriggers,omitempty"`
	// AliasApnMap map Alias APN to Core APN.
	// Format: NI+OI: NI+OI
	// Optional
	// NOTE: If defined as map[string]string, when smfsm call sm.Config.Unmarshal(&cfg), will produce an error and causes the program to exit
	AliasApnMap map[string]interface{} `mapstructure:"aliasApnMap" json:"aliasApnMap,omitempty"`
	// EquivalentPlmnMap map Partner Equivalent PLMN to Core PLMN.
	// Format: PLMN: PLMN
	// Optional
	// NOTE: If defined as map[string]string, when smfsm call sm.Config.Unmarshal(&cfg), will produce an error and causes the program to exit
	EquivalentPlmnMap map[string]interface{} `mapstructure:"equivalentPlmnMap" json:"equivalentPlmnMap,omitempty"`
	// This parameter defines the configurable value that limits the total number of N40Lite messages to be stored in the DB.
	// Default value: 100000
	// Optional.
	MaxN40LiteBufferedMsgCount *int32 `mapstructure:"maxN40LiteBufferedMsgCount" json:"maxN40LiteBufferedMsgCount,omitempty"`
	// Enable timer strategy configuration.\n
	// Default value nil.\n
	// Optional
	TimerCfg *TimerCfg `mapstructure:"timerCfg" json:"timerCfg,omitempty"`
	// Anpd-svc port, used for axsvc to stream which connection to eime-Anpd-svc \n
	// Optional
	AnpdCfg AnpdConfig `mapstructure:"anpdCfg" json:"anpdCfg,omitempty"`
	// Fixed the length of second fraction in a timestamp, used for formatting output of time types.\n
	// Default value: 0.\n
	// Optional
	TsSecFracLen uint8 `mapstructure:"tsSecFracLen" json:"tsSecFracLen,omitempty"`
}

type AnpdConfig struct {
	// Flag to disable the streaming for anpd <br>
	// Default value: false <br>
	// Optional
	Disable bool `mapstructure:"disable" json:"disable,omitempty"`
	// Map to decide the streaming for anpd <br>
	// Default value: N4 N11 <br>
	// Optional
	Interfaces map[string]bool `mapstructure:"interfaces" json:"interfaces,omitempty"`
}

// HTTP/2 message priority value from 0 to 31, as defined in TS29500
// clause 6.8.4.
//
// A message with 3gpp-Sbi-Message-Priority "0" has the highest priority.
//
// Actual 3gpp-Sbi-Message-Priority values (0..31) shall be configurable in NFs
//   - Initial http Request including GET/PUT requests: Default=24
//   - Subsequent http Request (including Notification Request) : Default=23
//   - http Response (Initial as well as subsequent): (< 23)
type SbiMsgPriority struct {
	InitHttpReq *uint8 `json:"initHttpReq,omitempty"`
	SubHttpReq  *uint8 `json:"subHttpReq,omitempty"`
	HttpRsp     *uint8 `json:"httpRsp,omitempty"`
}

// timeout value of each http client configuration
//
//  Purpose:
//    This is http timeout configuration to be used by corresponding http client.
//
//  Data model:
//    Refer to the description for attribute below.
//
//  Usage:
//    Used to define HttpClientTimeout under SmfSvcCfg.
//

type DualStackPreference string

const (
	DUAL_STACK_IPV4 DualStackPreference = "ipv4"
	DUAL_STACK_IPV6 DualStackPreference = "ipv6"
)

// PFD Management Configuration
//
//	Purpose:
//	  A list of static application ids configured which will be the same set that would be configured on UPF.
//
//	Data model:
//	  Refer to the description for attribute below.
//
//	Usage:
//	  Configuration static application id,it is used to check whether the application id in the policy data returned by the PCF is valid.
type PfdMgmtCfg struct {
	// A list of static app ids on smf.
	// When a pcc rule with app id is activated on smf, it checks if that app Id is static by it.
	// Static appIds are the globally known application ids which are configured in UPF.\n
	// When activating a pcc rule with an application Id on smf, it will check whether the application id is valid.\n
	// Default value nil.\n
	// Optional.
	StaticAppIds []string `mapstructure:"staticAppIds" json:"staticAppIds,omitempty"`
}

type SmfConfig struct {
	// The major configurations of sm-svc
	// Mandatory.
	SvcCfg SmfSvcCfg `mapstructure:"svcCfg" json:"svcCfg"`
	// The configurations of service-agent
	// TODO:
	ServAgent ServiceAgent `mapstructure:"servAgent" json:"servAgent,omitempty"`
	// Static UDM NF map. Key is the NfInstanceId. Value is NF's profile and the info used to be selected.
	// Optional
	UdmMap map[string]UdmNfProfile `mapstructure:"udmMap" json:"udmMap,omitempty"`
	// Static PCF NF map. Key is the NfInstanceId. Value is NF's profile and the info used to be selected.
	// Optional
	PcfMap map[string]PcfNfProfile `mapstructure:"pcfMap" json:"pcfMap,omitempty"`
	// Static UPF NF map. Key is the NfInstanceId. Value is NF's profile and the info used to be selected.
	// Optional
	UpfMap map[string]UpfNfProfile `mapstructure:"upfMap" json:"upfMap,omitempty"`
	// Static P-CSCF NF map. Key is the NfInstanceId. Value is NF's profile and the info used to be selected.
	// Optional
	PcscfMap map[string]PcscfNfProfile `mapstructure:"pcscfMap" json:"pcscfMap,omitempty"`
	// The ccMap using ChargingCharacteristics from udm or SlicePolicyProfile as key for the map
	CcMap map[string]ChargingCharacteristics `mapstructure:"ccMap" json:"ccMap,omitempty"`
	// The Static Pcc Map using defStaticPccRef from SlicePolicyProfile as key for the map
	StaticPccMap map[string]StaticPcc `mapstructure:"staticPccMap" json:"staticPccMap,omitempty"`
	// Dnn+Slice based local policies Dnn as key
	DnnProfileMap map[string]DnnProfile `mapstructure:"dnnProfileMap" json:"dnnProfileMap,omitempty"`
	// The SlicePolicyMap using SlicePolicyRef from DnnProfile as key
	SlicePolicyMap map[string]SlicePolicyProfile `mapstructure:"slicePolicyMap" json:"slicePolicyMap,omitempty"`
	// Provide assume positive profile for chf assume positive handing, using key provided by pcf or indicate by Dnn.
	ApProfileMap map[string]AssumePositiveProfile `mapstructure:"apProfileMap" json:"apProfileMap,omitempty"`
	// The local port and public IP address for smf acting as a DHCP client \n
	// Optional.
	DhcpEndpointCfg DhcpEndpointCfg `mapstructure:"dhcpEndpointCfg" json:"dhcpEndpointCfg,omitempty"`
	// DhcpProfileMap configuration using DhcpProfileRef from DnnProfile as key \n
	// Optional.
	DhcpProfileMap map[string]DhcpProfile `mapstructure:"dhcpProfileMap" json:"dhcpProfileMap,omitempty"`
	// AaaProfileMap management configuration,SMF send to external radius server \n
	// The AaaProfileMap using AaaProfileRef from DnnProfile as key \n
	// Optional.
	// deprecated
	AaaProfileMap map[string]ExternalAaaProfile `mapstructure:"aaaProfileMap" json:"aaaProfileMap,omitempty"`
	// Port on which to listen to radius change of authorization or disconnect requests \n
	// Default value 1812 \n
	// Optional.
	RadiusCoaDisPort uint16 `mapstructure:"radiusCoaDisPort" json:"radiusCoaDisPort,omitempty"`
	//deprecated
	// What percentage of the sessions' attaching request will be rejected by SMF.
	// Default value: 0 \n
	// Unit: percentage(%)
	SessRejectPercentage uint32 `mapstructure:"sessRejectPercentage" json:"sessRejectPercentage"`
	// PFD Management configuration, a list of static application ids configured.\n
	// It is used to check whether the application id in the policy data returned by the PCF is valid.\n
	// Default value null.\n
	// Optional.
	PfdMgmtConfiguration PfdMgmtCfg `mapstructure:"pfdMgmtConfiguration" json:"pfdMgmtConfiguration,omitempty"`
	// Receive notification from Controller based on CPU/Memory recource Threshold
	// Optional
	NasOverloadControl NasOverload `mapstructure:"nasOverloadControl" json:"nasOverloadControl,omitempty"`
	// Receive notification from Controller based on CPU/Memory recource Threshold
	// Optional
	LoadAndOverloadControl LoadAndOverloadControl `mapstructure:"loadAndOverloadControl" json:"loadAndOverloadControl,omitempty"`
	// SMF Configured IP pools
	// The key is IP pool Name
	// Default value nil
	// Optional
	IpPools map[string]IpPoolInst `mapstructure:"ipPools" json:"ipPools,omitempty"`
	// Operator specific EPCO container at SMF NF level
	// a container's config will take effect only if it is not present under dnn level OperatorPCOContainerConfig
	// Optional
	OperatorPCOContainerConfig *OperatorPCOContainerConfig `mapstructure:"operatorPCOContainerConfig" json:"operatorPCOContainerConfig,omitempty"`
	// Configure ePDG server addresses or FQDN
	// Default value is nil
	// Optional
	EpdgServers []EpdgServer `mapstructure:"epdgServers" json:"epdgServers,omitempty"`
	// The Error handle template set for diameter, the key is template name. Different Dnn may refer to different error handle template
	// Default value is nil
	// Optional
	DiameterErrorHandleMap map[string][]DiameterErrorHandleProfile `mapstructure:"diameterErrorHandleMap" json:"diameterErrorHandleMap,omitempty"`
}

// OperatorPCOContainerConfig
//
//	Purpose:
//	  Configure Operator PCO/EPCO Container.
//
//	Data model:
//	  Refer to the description for attribute below.
//
//	Usage:
//	  Configure in smfConfig and dnnProfile.
type OperatorPCOContainerConfig struct {
	// default MCC-MNC for all containers
	// this has to be present if mcc mnc is absent under one of OperatorPCOContainers
	// the format is mcc-mnc
	// Optional
	DefMccMnc string `mapstructure:"defMccMnc" json:"defMccMnc,omitempty"`
	// configure list of PCO containers with Container Id as Key
	// Optional
	OperatorPCOContainers map[string]OperatorPCOContainer `mapstructure:"operatorPCOContainers" json:"operatorPCOContainers,omitempty"`
}

// OperatorPCOContainer
//
//	Purpose:
//	  Configure Operator PCO/EPCO Container.
//
//	Data model:
//	  Refer to the description for attribute below.
//
//	Usage:
//	  Configure in OperatorPCOContainerConfig.
type OperatorPCOContainer struct {
	// Mcc carried in this PCO/EPCO container
	// Default value is "" and top level default value will be used
	// Optional
	Mcc string `mapstructure:"mcc" json:"mcc,omitempty"`
	// Mnc carried in this PCO/EPCO container
	// Default value is "" and top level default value will be used
	// Optional
	Mnc string `mapstructure:"mnc" json:"mnc,omitempty"`
	// enable/disable this pco container.\n
	// default value false.\n
	// Optional
	Enabled bool `mapstructure:"enabled" json:"enabled,omitempty"`
	// container value, FF01 and FF02 do not need to configure this
	// default value is ""
	// Optional
	PCOContainerValue string `mapstructure:"pCOContainerValue" json:"pCOContainerValue,omitempty"`
}

// EpdgServer
//
//	Purpose:
//	  Configure ePDG server addresses or FQDN.
//
//	Data model:
//	  Refer to the description for attribute below.
//
//	Usage:
//	  Configure in SmfConfig.
type EpdgServer struct {
	// PCO containerID for IPV4, when configured, epdg server address will be passed to UE via PCO
	// Default value is ""
	// optional
	PcoContainerIdV4 string `mapstructure:"pcoContainerIdV4" json:"pcoContainerIdV4,omitempty"`
	// PCO containerID for IPV6, when configured, epdg server address will be passed to UE via PCO
	// Default value is ""
	// optional
	PcoContainerIdV6 string `mapstructure:"pcoContainerIdV6" json:"pcoContainerIdV6,omitempty"`
	// IPv4 address or FQDN, when fqdn is configured it means it has separate FQDNs for v4 and v6, otherwise fqdnV4V6 should be configured in stead
	// Default value is ""
	// optional
	AddressV4 string `mapstructure:"addressV4" json:"addressV4,omitempty"`
	// IPv6 address or FQDN, when fqdn is configured it means it has separate FQDNs for v4 and v6, otherwise fqdnV4V6 should be configured in stead
	// Default value is ""
	// optional
	AddressV6 string `mapstructure:"addressV6" json:"addressV6,omitempty"`
	// fqdnV4V6 is fqdn with AAA DNS record which resolves to both IPv4 and IPv6 address, when configured, no need to configure addressV4 nor addressV6
	// Default value is ""
	// optional
	FqdnV4V6 string `mapstructure:"fqdnV4V6" json:"fqdnV4V6,omitempty"`
}

// AaaClientInfo
//
//  Purpose:
//    Define aaa-client service related information.
//
//  Data model:
//    Refer to the description for attribute below.
//
//  Usage:
//    Configure smf and aaa-client service communication information.
//

type AaaClientInfo struct {
	// The aaa-client service fqdn
	// Optional.
	Fqdn string `mapstructure:"fqdn" json:"fqdn,omitempty"`
	// The aaa-client service port
	// Optional.
	Port uint16 `mapstructure:"port" json:"port,omitempty"`
	// The origin host used when aaa-client communicates with dn-aaa server
	// Optional.
	OriginHost string `mapstructure:"originHost" json:"originHost,omitempty"`
}

// NrfInstance
//
//	Purpose:
//	  Configure NRF instance related information,such as fqdn/port.
//
//	Data model:
//	  Refer to the description for attribute below.
//
//	Usage:
//	  Configure in SmfSvcCfg.
type NrfInstance struct {
	// NRF NF's fqdn, used for SBA-HTTP connection with NRF \n
	// Mandatory
	Fqdn string `mapstructure:"fqdn" json:"fqdn,omitempty"`
	// NRF NF's port, used for SBA-HTTP connection with NRF \n
	// Optional
	Port uint16 `mapstructure:"port" json:"port,omitempty"`
	// Priority of this NRF,lower values indicate a higher priority
	// Value: 0 - 65535
	// Default: 65535, means lowest priority
	// Optional
	Priority *uint16 `mapstructure:"priority" json:"priority,omitempty"`
	// Indicate whether the FQDN is SRV virtual FQDN
	// Default: false
	// Optional
	IsSRV bool `mapstructure:"isSRV" json:"isSRV,omitempty"`
}

type LatencyBuckets struct {
	// The Total is corresponds to the total latency metrics.
	// Uint: millisecond
	// Default: [1, 10, 50, 100, 200, 300, 400, 500, 1000, 2000, 4000, 5000, 10000]
	// Optional
	Total []uint32 `mapstructure:"total"    json:"total,omitempty"`
	// The External is corresponds to the external latency metrics.
	// Uint: millisecond
	// Default: [1, 10, 50, 100, 200, 300, 400, 500, 1000, 2000, 4000, 5000, 10000]
	// Optional
	External []uint32 `mapstructure:"external"    json:"external,omitempty"`
	// The Internal is corresponds to the internal latency metrics.
	// Uint: millisecond
	// Default: [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 4000, 5000]
	// Optional
	Internal []uint32 `mapstructure:"internal"    json:"internal,omitempty"`
}

func (n *NrfInstance) GetPriority() uint16 {
	if n.Priority != nil {
		return *n.Priority
	}
	// Default: 65535, means lowest priority
	return 65535
}
